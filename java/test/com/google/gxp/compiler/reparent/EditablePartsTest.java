/*
 * Copyright (C) 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.gxp.compiler.reparent;

import com.google.gxp.compiler.alerts.AlertSetBuilder;
import com.google.gxp.compiler.alerts.SourcePosition;
import com.google.gxp.compiler.alerts.common.BadNodePlacementError;
import com.google.gxp.compiler.alerts.common.UnknownAttributeError;
import com.google.gxp.compiler.base.AbstractNode;
import com.google.gxp.compiler.base.Conditional;
import com.google.gxp.compiler.base.Expression;
import com.google.gxp.compiler.base.Parameter;
import com.google.gxp.compiler.base.Import;
import com.google.gxp.compiler.base.Node;
import com.google.gxp.compiler.base.StringConstant;
import com.google.gxp.compiler.GxpcTestCase;
import com.google.gxp.compiler.parser.NullNamespace;

import static com.google.gxp.testing.MoreAsserts.*;

/**
 * Tests {@link EditableParts}.
 */
public class EditablePartsTest extends GxpcTestCase {
  private static final SourcePosition PARTS_POS =
      new SourcePosition("[parts pos]");
  private static final SourcePosition NODE_POS =
      new SourcePosition("[node pos]");
  private static final Node FROM_NODE =
      new AbstractNode(NODE_POS, "[source node]"){};

  // The alerts we expect to be generated by 'parts'.
  AlertSetBuilder expectedAlerts = new AlertSetBuilder();

  // The alerts actually generated by 'parts'.
  AlertSetBuilder actualAlerts = new AlertSetBuilder();

  // The EditableParts that the test will operate on.
  EditableParts parts = new EditableParts(actualAlerts, FROM_NODE);

  public void tearDown() {
    parts.reportUnused();

    // Verify that the alerts we expect are actually generated.
    assertEquals(expectedAlerts.buildAndClear(),
                 actualAlerts.buildAndClear());
  }

  public void testBaseCase() {
    Expression content = parts.getContent();
    assertEquals("", ((StringConstant) content).evaluate());
    assertTrue(parts.getImports().isEmpty());
    assertTrue(parts.getParameters().isEmpty());
  }

  // used to make each injected value unique
  private static int currentValue = 0;

  private Expression injectValue() {
    Expression value = new StringConstant(NODE_POS, null,
                                          "[" + (currentValue++) + "]");
    parts.accumulate(value);
    return value;
  }

  public void testWithValue() {
    Expression value = injectValue();
    assertEquals(value, parts.getContent());
  }

  public void testWithValues() {
    Expression value1 = injectValue();
    Expression value2 = injectValue();
    assertEquals(concat(null, value1, value2), parts.getContent());
  }

  public void testUnusedValue() {
    Expression value = injectValue();
    expectedAlerts.add(new BadNodePlacementError(value, FROM_NODE));
  }

  public void testUnusedValues() {
    Expression value1 = injectValue();
    Expression value2 = injectValue();
    expectedAlerts.add(new BadNodePlacementError(value1, FROM_NODE));
    expectedAlerts.add(new BadNodePlacementError(value2, FROM_NODE));
  }

  private Import injectImport(String s) {
    Import node = classImport(s);
    parts.accumulate(node);
    return node;
  }

  public void testWithImport() {
    Import imp = injectImport("com.google.Foo");
    assertContentsInOrder(parts.getImports(), imp);
  }

  public void testWithImports() {
    Import imp1 = injectImport("com.google.Foo");
    Import imp2 = injectImport("com.google.Bar");
    assertContentsInOrder(parts.getImports(), imp1, imp2);
  }

  public void testUnusedImports() {
    Import node = injectImport("com.google.Foo");
    expectedAlerts.add(new BadNodePlacementError(node, FROM_NODE));
  }

  private Parameter injectParameter() {
    Parameter node = param("hello", "world", null);
    parts.accumulate(node);
    return node;
  }

  public void testWithParameters() {
    Parameter node = injectParameter();
    assertContentsInOrder(parts.getParameters(), node);
  }

  public void testUnusedParameters() {
    Parameter node = injectParameter();
    expectedAlerts.add(new BadNodePlacementError(node, FROM_NODE));
  }

  private Attribute injectAttribute() {
    String attrValue = "[foo's value]";
    Attribute node = new Attribute(FROM_NODE, NullNamespace.INSTANCE, "foo",
                                   new StringConstant(FROM_NODE, null,
                                                      attrValue),
                                   null, null);
    parts.accumulate(node);
    return node;
  }

  public void testWithAttributes() {
    String attrValue =
        ((StringConstant) injectAttribute().getValue()).evaluate();
    AttributeMap attrMap = parts.getAttributes();
    assertEquals(attrValue, attrMap.get("foo", null));
  }

  public void testUnusedAttributes() {
    Attribute attr = injectAttribute();
    expectedAlerts.add(new UnknownAttributeError(FROM_NODE, attr));
  }

  private Conditional.Clause injectClause() {
    Conditional.Clause clause = clause(expr("true"), expr("0"));
    parts.accumulate(clause);
    return clause;
  }

  public void testWithClause() {
    Conditional.Clause clause = injectClause();
    assertContentsInOrder(parts.getClauses(), clause);
  }

  public void testWithClauses() {
    Conditional.Clause clause1 = injectClause();
    Conditional.Clause clause2 = injectClause();
    assertContentsInOrder(parts.getClauses(), clause1, clause2);
  }

  public void testUnusedClauses() {
    Conditional.Clause clause = injectClause();
    expectedAlerts.add(new BadNodePlacementError(clause, FROM_NODE));
  }
}
