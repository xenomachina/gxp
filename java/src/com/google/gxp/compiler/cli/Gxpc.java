/*
 * Copyright (C) 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.gxp.compiler.cli;

import com.google.common.base.Charsets;
import com.google.common.base.Join;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.gxp.compiler.CompilationManager;
import com.google.gxp.compiler.CompilationSet;
import com.google.gxp.compiler.CompilationUnit;
import com.google.gxp.compiler.SimpleCompilationManager;
import com.google.gxp.compiler.alerts.Alert;
import com.google.gxp.compiler.alerts.Alert.Severity;
import com.google.gxp.compiler.alerts.AlertCounter;
import com.google.gxp.compiler.alerts.AlertPolicy;
import com.google.gxp.compiler.alerts.AlertSet;
import com.google.gxp.compiler.alerts.AlertSetBuilder;
import com.google.gxp.compiler.alerts.AlertSink;
import com.google.gxp.compiler.alerts.UniquifyingAlertSink;
import com.google.gxp.compiler.alerts.common.IOError;
import com.google.gxp.compiler.base.OutputLanguage;
import com.google.gxp.compiler.codegen.CodeGeneratorFactory;
import com.google.gxp.compiler.depend.DependencyGraph;
import com.google.gxp.compiler.dot.DotWriter;
import com.google.gxp.compiler.dot.GraphRenderer;
import com.google.gxp.compiler.dot.ReflectiveGraphRenderer;
import com.google.gxp.compiler.fs.FileRef;
import com.google.gxp.compiler.fs.FileSystem;
import com.google.gxp.compiler.fs.SystemFileSystem;
import com.google.gxp.compiler.parser.Parser;
import com.google.gxp.compiler.parser.SaxXmlParser;
import com.google.gxp.compiler.parser.SourceEntityResolver;
import com.google.gxp.compiler.schema.BuiltinSchemaFactory;
import com.google.gxp.compiler.schema.DelegatingSchemaFactory;
import com.google.gxp.compiler.schema.FileBackedSchemaFactory;
import com.google.gxp.compiler.schema.SchemaFactory;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Writer;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Callable;

import org.kohsuke.args4j.CmdLineException;

/**
 * The GXP compiler, "gxpc". The command line interface for generating code and
 * XMB files from GXP files.
 */
public class Gxpc implements Callable<AlertSet> {
  private final Set<FileRef> sourceFiles;
  private final Set<FileRef> schemaFiles;
  private final Set<OutputLanguage> outputLanguages;
  private final CodeGeneratorFactory codeGeneratorFactory;
  private final Set<FileRef> allowedOutputs;
  private final Set<Phase> dotPhases;
  private final FileRef dependencyFile;
  private final FileRef propertiesFile;
  private final AlertPolicy alertPolicy;
  private final SourceEntityResolver entityResolver;

  /**
   * Creates an instance of the compiler with the specified configuration.
   */
  public Gxpc(GxpcConfiguration config) throws InvalidConfigException {
    // TODO(laurence): use config.isDebugEnabled()
    // TODO(laurence): use config.getWarnFlags()

    validateAllowedOutputs(config.getAllowedOutputFileRefs(),
                           config.getOutputLanguages(),
                           config.getSourceFiles());

    sourceFiles = ImmutableSet.copyOf(config.getSourceFiles());
    schemaFiles = ImmutableSet.copyOf(config.getSchemaFiles());
    outputLanguages = ImmutableSet.copyOf(config.getOutputLanguages());
    codeGeneratorFactory = config.getCodeGeneratorFactory();
    allowedOutputs = ImmutableSet.copyOf(config.getAllowedOutputFileRefs());
    dotPhases = ImmutableSet.copyOf(config.getDotPhases());
    dependencyFile = config.getDependencyFile();
    propertiesFile = config.getPropertiesFile();
    alertPolicy = config.getAlertPolicy();
    entityResolver = config.getEntityResolver();
  }

  /**
   * Executes compilation and returns set of {@code Alert}s generated by
   * compile.
   */
  public AlertSet call() {
    AlertSetBuilder alertSetBuilder = new AlertSetBuilder();
    call(alertSetBuilder);
    return alertSetBuilder.buildAndClear();
  }

  /**
   * Executes compilation and passes the {@code Alert}s generated by
   * compile to the {@link AlertSink}
   */
  public void call(AlertSink alertSink) {
    // build up a schema factory
    SchemaFactory schemaFactory = new DelegatingSchemaFactory(
        new FileBackedSchemaFactory(alertSink, schemaFiles),
        new BuiltinSchemaFactory(alertSink));

    Parser parser = new Parser(schemaFactory, SaxXmlParser.INSTANCE, entityResolver);
    CompilationManager manager = readCompilationManager();
    CompilationSet.Builder compilationSetBuilder =
        new CompilationSet.Builder(parser, codeGeneratorFactory, manager)
                .setPropertiesFile(propertiesFile);
    CompilationSet compilationSet = compilationSetBuilder.build(sourceFiles);

    outputDotFiles(compilationSet, alertSink);
    Predicate<FileRef> shouldCompileFilePredicate =
        new Predicate<FileRef>() {
          public boolean apply(FileRef fnam) {
            return allowedOutputs.isEmpty() || allowedOutputs.contains(fnam);
          }
        };
    compilationSet.compile(alertSink, alertPolicy, outputLanguages,
                           shouldCompileFilePredicate);
    // We don't need to account for the old dependency graph at all.
    // - There is one .gxd file for each BUILD rule, so we don't need to worry
    //   about preserving the .gxd file if other targets are run in the mean
    //   time (i.e., //java/foo, then //java/bar, then //java/foo again).
    // - All source .gxp files that are in the transitive dependecies of any
    //   BUILD target are included in the compilation units, so we know that
    //   all relevant nodes will be listed in the compilation set
    writeCompilationManager(new DependencyGraph(compilationSet));
  }

  private void outputDotFiles(CompilationSet compilationSet, AlertSink alertSink) {
    List<CompilationUnit> compilationUnits = compilationSet.getCompilationUnits();
    int i = 0;
    for (Phase phase : Phase.values()) {
      i++;
      if (dotPhases.contains(phase)) {
        String suffix = String.format(".%02d.%s.dot", i,
                                      phase.name().toLowerCase().replace("_", "-"));
        for (CompilationUnit compilationUnit : compilationUnits) {
          FileRef fileRef = compilationUnit.getSourceFileRef().removeExtension().addSuffix(suffix);
          try {
            Writer writer = fileRef.openWriter(Charsets.US_ASCII);
            try {
              DotWriter out = new DotWriter(writer);
              GraphRenderer<Object> renderer =
                  new ReflectiveGraphRenderer(phase.name().toLowerCase());
              renderer.renderGraph(out, phase.getForest(compilationUnit).getChildren());
            } finally {
              writer.close();
            }
          } catch (IOException iox) {
            alertSink.add(new IOError(fileRef, iox));
          }
        }
      }
    }
  }

  private CompilationManager readCompilationManager() {
    CompilationManager manager = SimpleCompilationManager.INSTANCE;

    if (dependencyFile != null) {
      try {
        ObjectInputStream ois = new ObjectInputStream(dependencyFile.openInputStream());
        Object read = ois.readObject();
        if (read instanceof CompilationManager) {
          manager = (CompilationManager) read;
        }
        ois.close();
      } catch (ClassCastException cce) {
        // use the default, fresh manager 
      } catch (ClassNotFoundException cnfe) {
        // use the default, fresh manager
      } catch (IOException ioe) {
        // use the default, fresh manager
      } catch (IllegalStateException ise) {
        // sometimes happens when deserializing on NFS. use the default.
      }
    }
    return manager;
  }

  private static String makeStripe(int count) {
    StringBuilder sb = new StringBuilder(count);
    for (int i = 0; i < count; i++) {
      sb.append('*');
    }
    return sb.toString();
  }

  private void writeCompilationManager(CompilationManager manager) {
    if (dependencyFile != null) {
      try {
        ObjectOutputStream oos = new ObjectOutputStream(dependencyFile.openOutputStream());
        oos.writeObject(manager);
        oos.close();
      } catch (IOException e) {
        // Fail silently. The compilation manager is only an optimization, so
        // it is ok if it gets lost
      }
    }
  }

  private static final String BANNER_STRIPE = makeStripe(79);

  public static final String GXPC_EMAIL_ADDRESS = "gxpc-eng@google.com";

  public static final String GXPC_BUG_BANNER =
      "\n"
      + BANNER_STRIPE
      + "\n\n  "
      + "Looks like you found a bug in gxpc! Please email " + GXPC_EMAIL_ADDRESS
      + "\n\n  "
      + "Please include the command-line arguments, full output (including the"
      + "\n  "
      + "stack trace) and the location of your client workspace in your report."
      + "\n\n"
      + BANNER_STRIPE;

  public static final String GXPC_LINKAGE_ERROR_BANNER =
      "\n"
      + BANNER_STRIPE
      + "\n\n  "
      + "Looks like there's something wrong with your client workspace!"
      + "\n  "
      + "Try doing a clean build."
      + "\n\n  "
      + "If the problem persists, feel free to contact " + GXPC_EMAIL_ADDRESS
      + "\n  "
      + "for assistance."
      + "\n\n"
      + BANNER_STRIPE;

  /**
   * Runs compiler based on command line arguments. This method is invoked by
   * the JVM when this class is run from the command line.
   */
  public static void main(String[] args) throws IOException {
    try {
      FileSystem sysFs = SystemFileSystem.INSTANCE;
      FileRef cwd = sysFs.parseFilename(System.getProperty("user.dir"));
      System.exit(main(sysFs, System.err, cwd, args));
    } catch (Throwable throwable) {
      // TODO(laurence): include gxpc version info?
      throwable.printStackTrace();
      if (throwable instanceof LinkageError) {
        System.err.println(GXPC_LINKAGE_ERROR_BANNER);
      } else {
        System.err.println(GXPC_BUG_BANNER);
      }
      System.exit(-1);
    }
  }

  /**
   * (Testable) helper method for running compiler based on command line
   * arguments. Untestable bits (like references to the {@code System} class)
   * should be placed in {@link #main(String[])} and passed to this method as
   * parameters.
   *
   * @param fs the {@code FileSystem} to use for input and output.
   * @param stderr where to print error messages.
   * @param args command-line arguments.
   */
  static int main(FileSystem fs, final Appendable stderr, FileRef cwd, String... args)
      throws IOException {
    try {
      final GxpcConfiguration config = new GxpcFlags(fs, stderr, cwd, args);
      return main(config, stderr);
    } catch (CmdLineException usageError) {
      stderr.append(usageError.getMessage() + "\n");
      return 1;
    }
  }

  /**
   * Core GXPC main method.  Runs the compiler based on a {@code GxpcConfiguration}
   * and {@code stderr}.
   *
   * @param config the {@code GxpcConfiguration} to use for compilation
   * @param stderr where to print error messages.
   */
  public static int main(final GxpcConfiguration config, final Appendable stderr) throws IOException {
    if (config.getSourceFiles().isEmpty()) {
      stderr.append("No input files\n");
      return 1;
    }

    final AlertPolicy alertPolicy = config.getAlertPolicy();
    AlertSink alertSink = new AlertSink() {
      public void addAll(AlertSet alertSet) {
        for (Alert alert : alertSet) {
          add(alert);
        }
      }

      public void add(Alert alert) {
        try {
          if (config.isVerboseEnabled() || alertPolicy.getSeverity(alert) != Severity.INFO) {
            stderr.append(alert.toString()).append("\n");
          }
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
    };

    alertSink = new UniquifyingAlertSink(alertSink);
    AlertCounter counter = new AlertCounter(alertSink, alertPolicy);

    try {
      new Gxpc(config).call(counter);
      return (counter.getErrorCount() > 0) ? 1 : 0;
    } catch (InvalidConfigException invalidConfigException) {
      stderr.append(invalidConfigException.getMessage() + "\n");
      return 1;
    }
  }

  /**
   * Indicates that the GxpcConfiguration is invalid in some way.
   */
  public static class InvalidConfigException extends Exception {
    private static final long serialVersionUID = -1;

    private InvalidConfigException(String message) {
      super(message);
    }
  }

  /**
   * Checks that all of {@code allowedOutputs} can actually be created by the
   * specified {@code CompilationUnit}s.
   *
   * @throws InvalidConfigException if impossible allowed output is found.
   */
  private static void validateAllowedOutputs(Set<FileRef> allowedOutputs,
                                             Iterable<OutputLanguage> outputLanguages,
                                             Iterable<FileRef> sourceFileRefs)
      throws InvalidConfigException {
    if (!allowedOutputs.isEmpty()) {
      Set<FileRef> possibleOutputs = computePossibleOutputs(outputLanguages, sourceFileRefs);
      List<String> impossibleOutputs = Lists.newArrayList();
      for (FileRef allowedOutput : allowedOutputs) {
        if (!possibleOutputs.contains(allowedOutput)) {
          impossibleOutputs.add(allowedOutput.toFilename());
        }
      }
      if (!impossibleOutputs.isEmpty()) {
        Collections.sort(impossibleOutputs);
        throw new InvalidConfigException(
            "The following are listed as allowed output files but are not"
            + " possible given the specified inputs: "
            + Join.join(", ", impossibleOutputs));
      }
    }
  }

  /**
   * Compute the outputs that are possible based on the input files and
   * requested output languages.
   */
  private static Set<FileRef> computePossibleOutputs(Iterable<OutputLanguage> outputLanguages,
                                                     Iterable<FileRef> sourceFileRefs) {
    Set<FileRef> result = Sets.newHashSet();
    for (FileRef sourceFileRef : sourceFileRefs) {
      for (OutputLanguage language : outputLanguages) {
        FileRef outputFileRef = sourceFileRef.removeExtension().addSuffix(language.getSuffix());
        result.add(outputFileRef);
      }
    }
    return result;
  }
}
